---
title: Quick Start
description: Get started with Flutter Workmanager in minutes
---

## Installation

Add `workmanager` to your `pubspec.yaml`:

```yaml
dependencies:
  workmanager: ^0.8.0
```

Then run:
```bash
flutter pub get
```

> The platform-specific packages are automatically included through the federated plugin system.

## Platform Setup

### Android
Android works automatically - no additional setup required! ‚úÖ

### iOS
iOS requires a 5-minute setup in Xcode. Choose your approach based on your needs:

#### Option A: Periodic Tasks (Recommended for most use cases)
For regular data sync, notifications, cleanup - uses iOS Background Fetch:

1. **Enable Background Modes** in Xcode target capabilities ([Xcode Help](https://help.apple.com/xcode/mac/current/#/devbfa1532c4)):
   - Background fetch ‚úÖ

2. **Add to Info.plist**:
```xml
<key>UIBackgroundModes</key>
<array>
    <string>fetch</string>
</array>
```

3. **No AppDelegate configuration needed!** ‚úÖ
   
   The Background Fetch approach works automatically - just schedule tasks from your Dart code.

#### Option B: Processing Tasks (For complex operations)
For file uploads, data processing, longer tasks - uses BGTaskScheduler:

1. **Enable Background Modes** in Xcode target capabilities ([Xcode Help](https://help.apple.com/xcode/mac/current/#/devbfa1532c4)):
   - Background processing ‚úÖ

2. **Add to Info.plist**:
```xml
<key>UIBackgroundModes</key>
<array>
    <string>processing</string>
</array>

<key>BGTaskSchedulerPermittedIdentifiers</key>
<array>
    <string>com.yourapp.processing_task</string>
</array>
```

3. **Configure AppDelegate.swift** (required for BGTaskScheduler):
```swift
import workmanager_apple

// In application didFinishLaunching
WorkmanagerPlugin.registerBGProcessingTask(
  withIdentifier: "com.yourapp.processing_task"
)
```

<Info>
**Why BGTaskScheduler registration is needed:** iOS requires explicit registration of background task identifiers for security and system resource management. The task identifier in Info.plist tells iOS which background tasks your app can schedule, while the AppDelegate registration connects the identifier to the actual task handler. Background Fetch (Option A) doesn't require this since it uses the simpler, system-managed approach.
</Info>

<Success>
**Which option to choose?** Use **Option A (Periodic Tasks)** for most use cases like data sync, notifications, and cleanup. Use **Option B (Processing Tasks)** only when you need longer execution time or fine-grained control over task scheduling.
</Success>

## Basic Usage

### 1. Create Background Task Handler

```dart
@pragma('vm:entry-point')
void callbackDispatcher() {
  Workmanager().executeTask((task, inputData) async {
    print("Background task: $task");
    
    switch (task) {
      case "data_sync":
        await syncDataWithServer();
        break;
      case "cleanup": 
        await cleanupOldFiles();
        break;
    }
    
    return Future.value(true);
  });
}
```

### 2. Initialize in main()

```dart
void main() {
  Workmanager().initialize(
    callbackDispatcher,
    isInDebugMode: true,
  );
  
  runApp(MyApp());
}
```

### 3. Schedule Tasks

```dart
class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(title: Text('Workmanager Demo')),
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              ElevatedButton(
                onPressed: () {
                  // Schedule a one-time task
                  Workmanager().registerOneOffTask(
                    "sync-task",
                    "data_sync",
                    initialDelay: Duration(seconds: 10),
                  );
                },
                child: Text('Sync Data (One-time)'),
              ),
              SizedBox(height: 20),
              ElevatedButton(
                onPressed: () {
                  // Schedule a periodic task
                  Workmanager().registerPeriodicTask(
                    "cleanup-task",
                    "cleanup",
                    frequency: Duration(hours: 24),
                  );
                },
                child: Text('Daily Cleanup (Periodic)'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

## Task Results

Your background tasks can return:

- `Future.value(true)` - ‚úÖ Task successful
- `Future.value(false)` - üîÑ Task should be retried
- `Future.error(...)` - ‚ùå Task failed

## Key Points

- **Callback Dispatcher**: Must be a top-level function (not inside a class)
- **Separate Isolate**: Background tasks run in isolation - initialize dependencies inside the task
- **Platform Differences**: 
  - Android: Reliable background execution, 15-minute minimum frequency
  - iOS: 30-second limit, execution depends on user patterns and device state

## Debugging

Enable debug mode to see notifications when tasks run:

```dart
Workmanager().initialize(
  callbackDispatcher,
  isInDebugMode: true, // Shows debug notifications
);
```

Add error handling:

```dart
@pragma('vm:entry-point')
void callbackDispatcher() {
  Workmanager().executeTask((task, inputData) async {
    try {
      // Your task logic
      return Future.value(true);
    } catch (e) {
      print('Task failed: $e');
      return Future.value(false); // Retry
    }
  });
}
```

## Next Steps

- **[Use Cases](usecases/data-sync)** - See real-world examples
- **[Example App](https://github.com/fluttercommunity/flutter_workmanager/tree/main/example)** - Complete working demo