---
title: Quick Start
description: Get started with Flutter Workmanager in minutes
---

## Installation

Add `workmanager` to your `pubspec.yaml`:

```yaml
dependencies:
  workmanager: ^0.8.0
```

Then run:
```bash
flutter pub get
```

> The platform-specific packages are automatically included through the federated plugin system.

## Platform Setup

### Android
Android works automatically - no additional setup required! ‚úÖ

### iOS
iOS requires a 5-minute setup in Xcode:

1. **Enable Background Modes** in Xcode target capabilities ([Xcode Help](https://help.apple.com/xcode/mac/current/#/devbfa1532c4)):
   - Background processing ‚úÖ
   - Background fetch ‚úÖ

2. **Add to Info.plist**:
```xml
<key>UIBackgroundModes</key>
<array>
    <string>processing</string>
    <string>fetch</string>
</array>

<key>BGTaskSchedulerPermittedIdentifiers</key>
<array>
    <string>your.task.identifier</string>
</array>
```

3. **Configure AppDelegate.swift**:
```swift
import workmanager

// In application didFinishLaunching
WorkmanagerPlugin.registerBGProcessingTask(
  withIdentifier: "your.task.identifier"
)
```

> **Why this configuration is needed:** iOS requires explicit registration of background task identifiers for security and system resource management. The task identifier in Info.plist tells iOS which background tasks your app can schedule, while the AppDelegate registration connects the identifier to the actual task handler. This prevents apps from scheduling unauthorized background work.

## Basic Usage

### 1. Create Background Task Handler

```dart
@pragma('vm:entry-point')
void callbackDispatcher() {
  Workmanager().executeTask((task, inputData) async {
    print("Background task: $task");
    
    switch (task) {
      case "data_sync":
        await syncDataWithServer();
        break;
      case "cleanup": 
        await cleanupOldFiles();
        break;
    }
    
    return Future.value(true);
  });
}
```

### 2. Initialize in main()

```dart
void main() {
  Workmanager().initialize(
    callbackDispatcher,
    isInDebugMode: true,
  );
  
  runApp(MyApp());
}
```

### 3. Schedule Tasks

```dart
class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: AppBar(title: Text('Workmanager Demo')),
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              ElevatedButton(
                onPressed: () {
                  // Schedule a one-time task
                  Workmanager().registerOneOffTask(
                    "sync-task",
                    "data_sync",
                    initialDelay: Duration(seconds: 10),
                  );
                },
                child: Text('Sync Data (One-time)'),
              ),
              SizedBox(height: 20),
              ElevatedButton(
                onPressed: () {
                  // Schedule a periodic task
                  Workmanager().registerPeriodicTask(
                    "cleanup-task",
                    "cleanup",
                    frequency: Duration(hours: 24),
                  );
                },
                child: Text('Daily Cleanup (Periodic)'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
```

## Task Results

Your background tasks can return:

- `Future.value(true)` - ‚úÖ Task successful
- `Future.value(false)` - üîÑ Task should be retried
- `Future.error(...)` - ‚ùå Task failed

## Key Points

- **Callback Dispatcher**: Must be a top-level function (not inside a class)
- **Separate Isolate**: Background tasks run in isolation - initialize dependencies inside the task
- **Platform Differences**: 
  - Android: Reliable background execution, 15-minute minimum frequency
  - iOS: 30-second limit, execution depends on user patterns and device state

## Debugging

Enable debug mode to see notifications when tasks run:

```dart
Workmanager().initialize(
  callbackDispatcher,
  isInDebugMode: true, // Shows debug notifications
);
```

Add error handling:

```dart
@pragma('vm:entry-point')
void callbackDispatcher() {
  Workmanager().executeTask((task, inputData) async {
    try {
      // Your task logic
      return Future.value(true);
    } catch (e) {
      print('Task failed: $e');
      return Future.value(false); // Retry
    }
  });
}
```

## Next Steps

- **[Use Cases](usecases/data-sync)** - See real-world examples
- **[Example App](https://github.com/fluttercommunity/flutter_workmanager/tree/main/example)** - Complete working demo