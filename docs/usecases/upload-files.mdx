---
title: Example - File Upload
description: Example implementation for background file uploads
---

# Example: Background File Upload

Upload user files in the background, even when the app is closed, ensuring reliable delivery when network conditions are good.

## When to Use This

- Photo backup apps
- Document sharing apps  
- Social media with image/video uploads
- Cloud storage synchronization
- Large file transfers that shouldn't block the UI

## Complete Implementation

### 1. Queue Files for Upload

```dart lib/services/upload_service.dart
import 'package:workmanager/workmanager.dart';
import 'package:http/http.dart' as http;
import 'dart:io';

class UploadService {
  static const String uploadTaskName = "file_upload_task";

  static void initialize() {
    Workmanager().initialize(callbackDispatcher);
  }

  static Future<void> queueFileUpload(String filePath, Map<String, dynamic> metadata) async {
    final taskId = "upload_${DateTime.now().millisecondsSinceEpoch}";
    
    Workmanager().registerOneOffTask(
      taskId,
      uploadTaskName,
      inputData: {
        'filePath': filePath,
        'metadata': metadata,
        'taskId': taskId,
      },
      constraints: Constraints(
        networkType: NetworkType.connected,
        requiresBatteryNotLow: true,
      ),
    );
  }
}

@pragma('vm:entry-point')
void callbackDispatcher() {
  Workmanager().executeTask((task, inputData) async {
    if (task == UploadService.uploadTaskName) {
      return await _uploadFile(inputData!);
    }
    return Future.value(false);
  });
}

Future<bool> _uploadFile(Map<String, dynamic> inputData) async {
  try {
    final filePath = inputData['filePath'] as String;
    final metadata = inputData['metadata'] as Map<String, dynamic>;
    final taskId = inputData['taskId'] as String;

    final file = File(filePath);
    if (!await file.exists()) {
      print('File not found: $filePath');
      return true; // Don't retry if file doesn't exist
    }

    // Create multipart request
    final uri = Uri.parse('https://api.yourapp.com/upload');
    final request = http.MultipartRequest('POST', uri);

    request.headers['Authorization'] = 'Bearer TOKEN';
    request.fields.addAll(
      metadata.map((k, v) => MapEntry(k, v.toString()))
    );
    
    final file = await http.MultipartFile.fromPath(
      'file', filePath
    );
    request.files.add(file);

    final response = await request.send().timeout(Duration(minutes: 5));
    
    if (response.statusCode == 200) {
      print('Upload successful: $taskId');
      await _markUploadComplete(filePath, taskId);
      return true;
    } else {
      print('Upload failed with status: ${response.statusCode}');
      return false; // Retry later
    }
  } catch (e) {
    print('Upload error: $e');
    return false; // Retry later
  }
}

Future<void> _markUploadComplete(String filePath, String taskId) async {
  final prefs = await SharedPreferences.getInstance();
  final completed = prefs.getStringList('completed_uploads') ?? [];
  completed.add(taskId);
  await prefs.setStringList('completed_uploads', completed);
}
```

### 2. UI Integration

```dart lib/widgets/file_upload_widget.dart
class FileUploadWidget extends StatefulWidget {
  @override
  _FileUploadWidgetState createState() => _FileUploadWidgetState();
}

class _FileUploadWidgetState extends State<FileUploadWidget> {
  List<String> _pendingUploads = [];

  @override
  void initState() {
    super.initState();
    _loadPendingUploads();
  }

  Future<void> _selectAndQueueFile() async {
    // Use your preferred file picker implementation
    final filePath = '/path/to/selected/file.jpg';
    
    // Queue for background upload
    await UploadService.queueFileUpload(filePath, {
      'filename': 'photo.jpg',
      'size': 1024000,
      'type': 'jpg',
      'userId': 'current_user_id',
    });

    setState(() {
      _pendingUploads.add('photo.jpg');
    });

    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text('File queued for upload')),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        ElevatedButton.icon(
          onPressed: _selectAndQueueFile,
          icon: Icon(Icons.cloud_upload),
          label: Text('Select File to Upload'),
        ),
        if (_pendingUploads.isNotEmpty) ...[
          SizedBox(height: 16),
          Text('Pending Uploads:', style: Theme.of(context).textTheme.subtitle1),
          ...(_pendingUploads.map((filename) => ListTile(
            leading: Icon(Icons.schedule),
            title: Text(filename),
            subtitle: Text('Waiting for background upload...'),
          ))),
        ],
      ],
    );
  }
}
```

## Platform-Specific Behavior

### Android
**Automatic handling:**
- Large file uploads continue even if app is killed
- Respects data saver mode and metered networks
- Retries with exponential backoff on failure

**Optimize for Android:**
```dart
Workmanager().registerOneOffTask(
  taskId,
  uploadTaskName,
  inputData: inputData,
  constraints: Constraints(
    networkType: NetworkType.unmetered, // Use WiFi when possible
    requiresCharging: true,              // For large files
    requiresDeviceIdle: false,           // Upload even when device in use
  ),
  backoffPolicy: BackoffPolicy.exponential,
  backoffPolicyDelay: Duration(minutes: 1),
);
```

### iOS
**iOS limitations:**
- 30-second execution limit for most tasks
- Use BGProcessingTask for longer uploads
- May be deferred until device is idle and charging

**For large files, use processing tasks:**
```dart
// Register in AppDelegate.swift
WorkmanagerPlugin.registerBGProcessingTask(withIdentifier: "large_file_upload")

// Schedule in Dart
Workmanager().registerProcessingTask(
  taskId,
  uploadTaskName,
  constraints: Constraints(
    networkType: NetworkType.connected,
    requiresCharging: true, // iOS prefers charging for processing tasks
  ),
);
```

## Advanced Features

### Progress Tracking
```dart
Future<bool> _uploadFileWithProgress(Map<String, dynamic> inputData) async {
  final file = File(inputData['filePath']);
  final fileSize = await file.length();
  int uploadedBytes = 0;

  final request = http.StreamedRequest('POST', Uri.parse('https://api.yourapp.com/upload'));
  
  final stream = file.openRead();
  stream.listen(
    (chunk) {
      uploadedBytes += chunk.length;
      final progress = (uploadedBytes / fileSize * 100).round();
      // Save progress to SharedPreferences for UI updates
      _saveUploadProgress(inputData['taskId'], progress);
    },
  );

  request.contentLength = fileSize;
  stream.pipe(request);
  
  final response = await request.send();
  return response.statusCode == 200;
}
```

### Retry Logic
```dart
Future<bool> _uploadWithRetry(Map<String, dynamic> inputData) async {
  const maxRetries = 3;
  int attempts = inputData['attempts'] ?? 0;

  final success = await _uploadFile(inputData);
  
  if (!success && attempts < maxRetries) {
    // Schedule retry with delay
    await Future.delayed(Duration(seconds: math.pow(2, attempts).toInt()));
    
    inputData['attempts'] = attempts + 1;
    return await _uploadWithRetry(inputData);
  }
  
  return success;
}
```

## Related Use Cases

- **[Data Sync](data-sync)** - Synchronize data with your backend
- **[Database Maintenance](database-maintenance)** - Clean up and optimize local data