---
title: "Sync Data Regularly"
description: "Automatically fetch and sync data from your API in the background"
---

# Background Data Synchronization

Keep your app's data fresh by automatically syncing with your backend API, even when the app is closed.

## When to Use This

- News apps fetching latest articles
- Social media apps syncing posts and messages  
- E-commerce apps updating product catalogs
- Weather apps refreshing forecasts
- Any app that needs fresh data from an API

## Complete Implementation

### 1. Set Up the Background Task

```dart lib/services/data_sync_service.dart
import 'package:workmanager/workmanager.dart';
import 'package:http/http.dart' as http;
import 'dart:convert';

class DataSyncService {
  static const String syncTaskName = "data_sync_task";
  static const String syncTaskId = "periodic_data_sync";

  static void initialize() {
    Workmanager().initialize(callbackDispatcher);
  }

  static void scheduleSync() {
    Workmanager().registerPeriodicTask(
      syncTaskId,
      syncTaskName,
      frequency: Duration(hours: 1), // Sync every hour
      constraints: Constraints(
        networkType: NetworkType.connected, // Require internet
        requiresBatteryNotLow: true,        // Don't drain battery
      ),
    );
  }

  static void cancelSync() {
    Workmanager().cancelByUniqueName(syncTaskId);
  }
}

@pragma('vm:entry-point')
void callbackDispatcher() {
  Workmanager().executeTask((task, inputData) async {
    try {
      switch (task) {
        case DataSyncService.syncTaskName:
          return await _performDataSync();
        default:
          return Future.value(false);
      }
    } catch (e) {
      print('Background sync failed: $e');
      return Future.value(false); // Retry on next opportunity
    }
  });
}

Future<bool> _performDataSync() async {
  try {
    // Fetch data from your API
    final response = await http.get(
      Uri.parse('https://api.yourapp.com/data'),
      headers: {'Authorization': 'Bearer YOUR_TOKEN'},
    ).timeout(Duration(seconds: 30));

    if (response.statusCode == 200) {
      final data = json.decode(response.body);
      
      // Store in local database (SQLite, Hive, etc.)
      await _storeDataLocally(data);
      
      print('Data sync completed successfully');
      return true;
    } else {
      print('API returned ${response.statusCode}');
      return false; // Retry later
    }
  } catch (e) {
    print('Sync error: $e');
    return false; // Retry later
  }
}

Future<void> _storeDataLocally(Map<String, dynamic> data) async {
  // Example using SharedPreferences for simple data
  final prefs = await SharedPreferences.getInstance();
  await prefs.setString('last_sync_data', json.encode(data));
  await prefs.setString('last_sync_time', DateTime.now().toIso8601String());
  
  // For complex data, use SQLite, Hive, or other local storage
}
```

### 2. Initialize in Your App

```dart main.dart
import 'package:flutter/material.dart';
import 'services/data_sync_service.dart';

void main() {
  DataSyncService.initialize();
  runApp(MyApp());
}

class MyApp extends StatefulWidget {
  @override
  _MyAppState createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  @override
  void initState() {
    super.initState();
    // Start background sync when app launches
    DataSyncService.scheduleSync();
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Data Sync App',
      home: DataSyncHomePage(),
    );
  }
}
```

### 3. Show Sync Status to Users

```dart lib/widgets/sync_status_widget.dart
class SyncStatusWidget extends StatefulWidget {
  @override
  _SyncStatusWidgetState createState() => _SyncStatusWidgetState();
}

class _SyncStatusWidgetState extends State<SyncStatusWidget> {
  String _lastSyncTime = "Never";

  @override
  void initState() {
    super.initState();
    _loadLastSyncTime();
  }

  Future<void> _loadLastSyncTime() async {
    final prefs = await SharedPreferences.getInstance();
    final syncTime = prefs.getString('last_sync_time');
    if (syncTime != null) {
      final dateTime = DateTime.parse(syncTime);
      setState(() {
        _lastSyncTime = timeago.format(dateTime);
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Card(
      child: ListTile(
        leading: Icon(Icons.sync),
        title: Text('Background Sync'),
        subtitle: Text('Last sync: $_lastSyncTime'),
        trailing: IconButton(
          icon: Icon(Icons.refresh),
          onPressed: () {
            // Trigger immediate sync (optional)
            _performManualSync();
          },
        ),
      ),
    );
  }

  void _performManualSync() {
    // Schedule an immediate one-off sync
    Workmanager().registerOneOffTask(
      "manual_sync_${DateTime.now().millisecondsSinceEpoch}",
      DataSyncService.syncTaskName,
      constraints: Constraints(networkType: NetworkType.connected),
    );
  }
}
```

## Platform-Specific Considerations

<Tabs>
  <Tab title="Android">
    **Android automatically handles**:
    - Task scheduling and retry logic
    - Battery optimization (Doze mode)
    - App standby mode restrictions
    - Network changes and availability

    **Best practices**:
    ```dart
    // Use appropriate constraints
    Workmanager().registerPeriodicTask(
      "data_sync",
      "sync_task",
      frequency: Duration(hours: 1),
      constraints: Constraints(
        networkType: NetworkType.connected,
        requiresBatteryNotLow: true, // Respect battery optimization
        requiresCharging: false,     // Don't wait for charging
      ),
    );
    ```

    **Minimum frequency**: 15 minutes (Android WorkManager limitation)
  </Tab>

  <Tab title="iOS">
    **iOS has additional restrictions**:
    - Background App Refresh must be enabled
    - Tasks may be limited to 30 seconds
    - iOS learns usage patterns and schedules accordingly
    - No guaranteed execution time

    **Setup required in AppDelegate.swift**:
    ```swift
    import workmanager

    // In application(_:didFinishLaunchingWithOptions:)
    WorkmanagerPlugin.registerPeriodicTask(
      withIdentifier: "data_sync_task", 
      frequency: NSNumber(value: 60 * 60) // 1 hour in seconds
    )
    ```

    **Info.plist configuration**:
    ```xml
    <key>BGTaskSchedulerPermittedIdentifiers</key>
    <array>
        <string>data_sync_task</string>
    </array>
    ```

    **Best practices**:
    - Keep sync operations under 30 seconds
    - Use incremental sync (only fetch changes)
    - Handle task expiration gracefully
  </Tab>
</Tabs>

## Testing Your Implementation

### Debug Mode
```dart
Workmanager().initialize(
  callbackDispatcher,
  isInDebugMode: true, // Shows notifications when tasks run
);
```

### Manual Testing
```dart
// Test your sync logic immediately
ElevatedButton(
  onPressed: () {
    Workmanager().registerOneOffTask(
      "test_sync",
      DataSyncService.syncTaskName,
      initialDelay: Duration(seconds: 5),
    );
  },
  child: Text('Test Sync'),
)
```

### Monitoring
```dart
Future<void> _checkSyncHealth() async {
  final prefs = await SharedPreferences.getInstance();
  final lastSync = prefs.getString('last_sync_time');
  
  if (lastSync != null) {
    final syncTime = DateTime.parse(lastSync);
    final hoursSinceSync = DateTime.now().difference(syncTime).inHours;
    
    if (hoursSinceSync > 6) {
      // Alert: Sync might not be working
      _showSyncWarning();
    }
  }
}
```

## Common Issues & Solutions

<AccordionGroup>
  <Accordion title="Sync Not Running">
    **Possible causes**:
    - Missing platform setup (Android/iOS configuration)
    - App battery optimization preventing background tasks
    - No network connectivity when task tries to run
    - App hasn't been used recently (iOS restriction)

    **Solutions**:
    - Verify platform setup is complete
    - Ask users to disable battery optimization for your app
    - Use network constraints appropriately
    - Encourage regular app usage
  </Accordion>

  <Accordion title="Partial Data Sync">
    **Implement incremental sync**:
    ```dart
    Future<bool> _performIncrementalSync() async {
      final prefs = await SharedPreferences.getInstance();
      final lastSyncTime = prefs.getString('last_sync_time') ?? '';
      
      final response = await http.get(
        Uri.parse('https://api.yourapp.com/data?since=$lastSyncTime'),
      );
      
      // Only sync changed data
      if (response.statusCode == 200) {
        final changes = json.decode(response.body);
        await _applyChanges(changes);
        return true;
      }
      return false;
    }
    ```
  </Accordion>

  <Accordion title="High Battery Usage">
    **Optimize your sync logic**:
    - Use appropriate frequency (not too often)
    - Add battery constraints
    - Implement smart syncing (only when data actually changed)
    - Use compression for large payloads
    - Cache API responses appropriately
  </Accordion>
</AccordionGroup>

## Related Use Cases

<CardGroup cols={2}>
  <Card title="Upload Files" icon="cloud-arrow-up" href="/usecases/upload-files">
    Upload user content in the background
  </Card>
  <Card title="Fetch Notifications" icon="bell" href="/usecases/fetch-notifications">
    Check for new notifications from your server
  </Card>
</CardGroup>