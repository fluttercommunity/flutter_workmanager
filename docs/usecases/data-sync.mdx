---
title: Example - Data Sync
description: Example implementation for syncing API data in background
---

# Example: API Data Sync

Keep your app's data fresh by automatically syncing with your backend API, even when the app is closed.

## When to Use This

- News apps fetching latest articles
- Social media apps syncing posts and messages  
- E-commerce apps updating product catalogs
- Weather apps refreshing forecasts
- Any app that needs fresh data from an API

## Complete Implementation

### 1. Set Up the Background Task

```dart lib/services/data_sync_service.dart
import 'package:workmanager/workmanager.dart';
import 'package:http/http.dart' as http;
import 'dart:convert';

class DataSyncService {
  static const String syncTaskName = "data_sync_task";
  static const String syncTaskId = "periodic_data_sync";

  static void initialize() {
    Workmanager().initialize(callbackDispatcher);
  }

  static void scheduleSync() {
    Workmanager().registerPeriodicTask(
      syncTaskId,
      syncTaskName,
      frequency: Duration(hours: 1), // Sync every hour
      constraints: Constraints(
        networkType: NetworkType.connected, // Require internet
        requiresBatteryNotLow: true,        // Don't drain battery
      ),
    );
  }

  static void cancelSync() {
    Workmanager().cancelByUniqueName(syncTaskId);
  }
}

@pragma('vm:entry-point')
void callbackDispatcher() {
  Workmanager().executeTask((task, inputData) async {
    try {
      switch (task) {
        case DataSyncService.syncTaskName:
          return await _performDataSync();
        default:
          return Future.value(false);
      }
    } catch (e) {
      print('Background sync failed: $e');
      return Future.value(false); // Retry on next opportunity
    }
  });
}

Future<bool> _performDataSync() async {
  try {
    // Fetch data from API
    final uri = Uri.parse('https://api.yourapp.com/data');
    final response = await http.get(
      uri,
      headers: {'Authorization': 'Bearer TOKEN'},
    ).timeout(Duration(seconds: 30));

    if (response.statusCode == 200) {
      final data = json.decode(response.body);
      await _storeDataLocally(data);
      return true;
    } else {
      print('API error: ${response.statusCode}');
      return false; // Retry later
    }
  } catch (e) {
    print('Sync failed: $e');
    return false;
  }
}

Future<void> _storeDataLocally(
  Map<String, dynamic> data
) async {
  final prefs = await SharedPreferences.getInstance();
  await prefs.setString('sync_data', json.encode(data));
  await prefs.setString(
    'sync_time', 
    DateTime.now().toIso8601String()
  );
}
```

### 2. Initialize in Your App

```dart main.dart
import 'package:flutter/material.dart';
import 'services/data_sync_service.dart';

void main() {
  DataSyncService.initialize();
  runApp(MyApp());
}

class MyApp extends StatefulWidget {
  @override
  _MyAppState createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  @override
  void initState() {
    super.initState();
    // Start background sync when app launches
    DataSyncService.scheduleSync();
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Data Sync App',
      home: DataSyncHomePage(),
    );
  }
}
```

### 3. Show Sync Status to Users

```dart lib/widgets/sync_status_widget.dart
class SyncStatusWidget extends StatefulWidget {
  @override
  _SyncStatusWidgetState createState() => _SyncStatusWidgetState();
}

class _SyncStatusWidgetState extends State<SyncStatusWidget> {
  String _lastSyncTime = "Never";

  @override
  void initState() {
    super.initState();
    _loadLastSyncTime();
  }

  Future<void> _loadLastSyncTime() async {
    final prefs = await SharedPreferences.getInstance();
    final syncTime = prefs.getString('last_sync_time');
    if (syncTime != null) {
      final dateTime = DateTime.parse(syncTime);
      setState(() {
        _lastSyncTime = timeago.format(dateTime);
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Card(
      child: ListTile(
        leading: Icon(Icons.sync),
        title: Text('Background Sync'),
        subtitle: Text('Last sync: $_lastSyncTime'),
        trailing: IconButton(
          icon: Icon(Icons.refresh),
          onPressed: () {
            // Trigger immediate sync (optional)
            _performManualSync();
          },
        ),
      ),
    );
  }

  void _performManualSync() {
    // Schedule an immediate one-off sync
    Workmanager().registerOneOffTask(
      "manual_sync_${DateTime.now().millisecondsSinceEpoch}",
      DataSyncService.syncTaskName,
      constraints: Constraints(networkType: NetworkType.connected),
    );
  }
}
```

## Platform-Specific Considerations

### Android
**Android automatically handles**:
- Task scheduling and retry logic
- Battery optimization (Doze mode)
- App standby mode restrictions
- Network changes and availability

**Best practices**:
```dart
// Use appropriate constraints
Workmanager().registerPeriodicTask(
  "data_sync",
  "sync_task",
  frequency: Duration(hours: 1),
  constraints: Constraints(
    networkType: NetworkType.connected,
    requiresBatteryNotLow: true, // Respect battery optimization
    requiresCharging: false,     // Don't wait for charging
  ),
);
```

**Minimum frequency**: 15 minutes (Android WorkManager limitation)

### iOS
**iOS has additional restrictions**:
- Background App Refresh must be enabled
- Tasks may be limited to 30 seconds
- iOS learns usage patterns and schedules accordingly
- No guaranteed execution time

**Setup required in AppDelegate.swift**:
```swift
import workmanager

// In application(_:didFinishLaunchingWithOptions:)
WorkmanagerPlugin.registerPeriodicTask(
  withIdentifier: "data_sync_task", 
  frequency: NSNumber(value: 60 * 60) // 1 hour in seconds
)
```

**Info.plist configuration**:
```xml
<key>BGTaskSchedulerPermittedIdentifiers</key>
<array>
    <string>data_sync_task</string>
</array>
```

**Best practices**:
- Keep sync operations under 30 seconds
- Use incremental sync (only fetch changes)
- Handle task expiration gracefully

## Testing Your Implementation

### Debug Mode
```dart
Workmanager().initialize(
  callbackDispatcher,
  isInDebugMode: true, // Shows notifications when tasks run
);
```

### Manual Testing
```dart
// Test your sync logic immediately
ElevatedButton(
  onPressed: () {
    Workmanager().registerOneOffTask(
      "test_sync",
      DataSyncService.syncTaskName,
      initialDelay: Duration(seconds: 5),
    );
  },
  child: Text('Test Sync'),
)
```

### Monitoring
```dart
Future<void> _checkSyncHealth() async {
  final prefs = await SharedPreferences.getInstance();
  final lastSync = prefs.getString('last_sync_time');
  
  if (lastSync != null) {
    final syncTime = DateTime.parse(lastSync);
    final hoursSinceSync = DateTime.now().difference(syncTime).inHours;
    
    if (hoursSinceSync > 6) {
      // Alert: Sync might not be working
      _showSyncWarning();
    }
  }
}
```

## Common Issues & Solutions

### Sync Not Running
**Possible causes**:
- Missing platform setup (Android/iOS configuration)
- App battery optimization preventing background tasks
- No network connectivity when task tries to run
- App hasn't been used recently (iOS restriction)

**Solutions**:
- Verify platform setup is complete
- Ask users to disable battery optimization for your app
- Use network constraints appropriately
- Encourage regular app usage

### Partial Data Sync
**Implement incremental sync**:
```dart
Future<bool> _performIncrementalSync() async {
  final prefs = await SharedPreferences.getInstance();
  final lastSyncTime = prefs.getString('last_sync_time') ?? '';
  
  final response = await http.get(
    Uri.parse('https://api.yourapp.com/data?since=$lastSyncTime'),
  );
  
  // Only sync changed data
  if (response.statusCode == 200) {
    final changes = json.decode(response.body);
    await _applyChanges(changes);
    return true;
  }
  return false;
}
```

### High Battery Usage
**Optimize your sync logic**:
- Use appropriate frequency (not too often)
- Add battery constraints
- Implement smart syncing (only when data actually changed)
- Use compression for large payloads
- Cache API responses appropriately

## Related Use Cases

- **[Upload Files](upload-files)** - Upload user content in the background
- **[Fetch Notifications](fetch-notifications)** - Check for new notifications from your server