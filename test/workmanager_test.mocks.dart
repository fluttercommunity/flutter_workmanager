// Mocks generated by Mockito 5.0.17 from annotations
// in workmanager/test/workmanager_test.dart.
// Do not manually edit this file.

import 'dart:async' as _i3;

import 'package:mockito/mockito.dart' as _i1;
import 'package:workmanager/src/options.dart' as _i4;
import 'package:workmanager/src/workmanager.dart' as _i2;

// ignore_for_file: avoid_redundant_argument_values
// ignore_for_file: avoid_setters_without_getters
// ignore_for_file: comment_references
// ignore_for_file: implementation_imports
// ignore_for_file: invalid_use_of_visible_for_testing_member
// ignore_for_file: prefer_const_constructors
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: camel_case_types

/// A class which mocks [Workmanager].
///
/// See the documentation for Mockito's code generation for more information.
class MockWorkmanager extends _i1.Mock implements _i2.Workmanager {
  MockWorkmanager() {
    _i1.throwOnMissingStub(this);
  }

  @override
  void executeTask(_i2.BackgroundTaskHandler? backgroundTask) =>
      super.noSuchMethod(Invocation.method(#executeTask, [backgroundTask]),
          returnValueForMissingStub: null);
  @override
  _i3.Future<void> initialize(Function? callbackDispatcher,
          {bool? isInDebugMode = false}) =>
      (super.noSuchMethod(
          Invocation.method(#initialize, [callbackDispatcher],
              {#isInDebugMode: isInDebugMode}),
          returnValue: Future<void>.value(),
          returnValueForMissingStub: Future<void>.value()) as _i3.Future<void>);
  @override
  _i3.Future<void> registerOneOffTask(String? uniqueName, String? taskName,
          {String? tag,
          _i4.ExistingWorkPolicy? existingWorkPolicy,
          Duration? initialDelay = Duration.zero,
          _i4.Constraints? constraints,
          _i4.BackoffPolicy? backoffPolicy,
          Duration? backoffPolicyDelay = Duration.zero,
          _i4.OutOfQuotaPolicy? outOfQuotaPolicy,
          Map<String, dynamic>? inputData}) =>
      (super.noSuchMethod(
          Invocation.method(#registerOneOffTask, [
            uniqueName,
            taskName
          ], {
            #tag: tag,
            #existingWorkPolicy: existingWorkPolicy,
            #initialDelay: initialDelay,
            #constraints: constraints,
            #backoffPolicy: backoffPolicy,
            #backoffPolicyDelay: backoffPolicyDelay,
            #outOfQuotaPolicy: outOfQuotaPolicy,
            #inputData: inputData
          }),
          returnValue: Future<void>.value(),
          returnValueForMissingStub: Future<void>.value()) as _i3.Future<void>);
  @override
  _i3.Future<void> registerPeriodicTask(String? uniqueName, String? taskName,
          {Duration? frequency,
          String? tag,
          _i4.ExistingWorkPolicy? existingWorkPolicy,
          Duration? initialDelay = Duration.zero,
          _i4.Constraints? constraints,
          _i4.BackoffPolicy? backoffPolicy,
          Duration? backoffPolicyDelay = Duration.zero,
          _i4.OutOfQuotaPolicy? outOfQuotaPolicy,
          Map<String, dynamic>? inputData}) =>
      (super.noSuchMethod(
          Invocation.method(#registerPeriodicTask, [
            uniqueName,
            taskName
          ], {
            #frequency: frequency,
            #tag: tag,
            #existingWorkPolicy: existingWorkPolicy,
            #initialDelay: initialDelay,
            #constraints: constraints,
            #backoffPolicy: backoffPolicy,
            #backoffPolicyDelay: backoffPolicyDelay,
            #outOfQuotaPolicy: outOfQuotaPolicy,
            #inputData: inputData
          }),
          returnValue: Future<void>.value(),
          returnValueForMissingStub: Future<void>.value()) as _i3.Future<void>);
  @override
  _i3.Future<void> cancelByUniqueName(String? uniqueName) =>
      (super.noSuchMethod(Invocation.method(#cancelByUniqueName, [uniqueName]),
          returnValue: Future<void>.value(),
          returnValueForMissingStub: Future<void>.value()) as _i3.Future<void>);
  @override
  _i3.Future<void> cancelByTag(String? tag) =>
      (super.noSuchMethod(Invocation.method(#cancelByTag, [tag]),
          returnValue: Future<void>.value(),
          returnValueForMissingStub: Future<void>.value()) as _i3.Future<void>);
  @override
  _i3.Future<void> cancelAll() =>
      (super.noSuchMethod(Invocation.method(#cancelAll, []),
          returnValue: Future<void>.value(),
          returnValueForMissingStub: Future<void>.value()) as _i3.Future<void>);
}
